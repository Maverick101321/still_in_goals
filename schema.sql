-- Enums
create type goal_category as enum ('academic', 'career_switch', 'health');
create type user_status as enum ('active', 'slumping', 'SOS');

-- Profiles table (extends auth.users)
create table public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  display_name text not null,
  goal_category goal_category not null,
  goal_description text,
  last_checkin_at timestamptz,
  streak_count int not null default 0,
  status user_status not null default 'active',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Check-ins
create table public.check_ins (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  content text not null,
  created_at timestamptz not null default now()
);

-- Emergency contacts
create table public.emergency_contacts (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  contact_email text not null,
  contact_name text not null,
  created_at timestamptz not null default now()
);

-- Peer matches
create table public.peer_matches (
  id bigint generated by default as identity primary key,
  user_id_1 uuid not null references auth.users(id) on delete cascade,
  user_id_2 uuid not null references auth.users(id) on delete cascade,
  matched_at timestamptz not null default now(),
  chat_channel_id text,
  constraint peer_matches_distinct_users check (user_id_1 <> user_id_2)
);

create index peer_matches_user_1_idx on public.peer_matches(user_id_1);
create index peer_matches_user_2_idx on public.peer_matches(user_id_2);

-- RLS
alter table public.profiles enable row level security;
alter table public.check_ins enable row level security;
alter table public.emergency_contacts enable row level security;
alter table public.peer_matches enable row level security;

-- Helpers for matched peers
create or replace function public.is_peer_match(target_user uuid)
returns boolean
language sql
stable
as $$
  select exists (
    select 1
    from public.peer_matches pm
    where (pm.user_id_1 = auth.uid() and pm.user_id_2 = target_user)
       or (pm.user_id_2 = auth.uid() and pm.user_id_1 = target_user)
  );
$$;

-- PROFILES policies
create policy "Profiles: self read"
  on public.profiles
  for select
  using (user_id = auth.uid());

create policy "Profiles: matched peers can read"
  on public.profiles
  for select
  using (public.is_peer_match(user_id));

create policy "Profiles: self insert"
  on public.profiles
  for insert
  with check (user_id = auth.uid());

create policy "Profiles: self update"
  on public.profiles
  for update
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

-- CHECK_INS policies
create policy "Check-ins: self read"
  on public.check_ins
  for select
  using (user_id = auth.uid());

create policy "Check-ins: self insert"
  on public.check_ins
  for insert
  with check (user_id = auth.uid());

create policy "Check-ins: self update"
  on public.check_ins
  for update
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

-- EMERGENCY_CONTACTS policies
create policy "Emergency contacts: self read"
  on public.emergency_contacts
  for select
  using (user_id = auth.uid());

create policy "Emergency contacts: self insert"
  on public.emergency_contacts
  for insert
  with check (user_id = auth.uid());

create policy "Emergency contacts: self update"
  on public.emergency_contacts
  for update
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

create policy "Emergency contacts: self delete"
  on public.emergency_contacts
  for delete
  using (user_id = auth.uid());

-- PEER_MATCHES policies
create policy "Peer matches: self read"
  on public.peer_matches
  for select
  using (user_id_1 = auth.uid() or user_id_2 = auth.uid());

create policy "Peer matches: self insert"
  on public.peer_matches
  for insert
  with check (user_id_1 = auth.uid() or user_id_2 = auth.uid());
